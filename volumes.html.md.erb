---
title: Configuring and Using PersistentVolumes
owner: PKS
---

<strong><%= modified_date %></strong>

This topic describes how to provision static and dynamic PersistentVolumes (PVs) for Pivotal Container Service (PKS) to run stateful apps.

For more information on storage management in Kubernetes, refer to the [Kubernetes documentation](https://kubernetes.io/docs/concepts/storage/persistent-volumes/). For more information about the supported vSphere topologies for PV storage, see [vSphere PersistentVolume Storage Options on vSphere](vsphere-persistent-storage.html).

For static PV provisioning, you do not need to specify a StorageClass. The PersistentVolumeClaim (PVC) does not need to reference a StorageClass. For dynamic PV provisioning, you must specify a StorageClass and define the PVC using a reference to that StorageClass. 

<p class="note"><strong>Note</strong>: Most of the YAML examples in this section use vSphere as the provisioner. In general the definition of storage classes, PVs, and PVCs are virtually the same, except for the provisioner definition in the YAML. Refer to the [provisioner section](https://kubernetes.io/docs/concepts/storage/storage-classes/) of the Kubernetes documentation for examples that are specific to your IaaS provider.</p>

## <a id='static-pv'></a>Provision a Static PV

To provision a static PV, you manually create a Virtual Machine Disk (VMDK) file to use as a storage backend for the PV. When the PV is created, Kubernetes knows which volume instance is ready for use. When a PVC or volumeClaimTemplate is requested, Kubernetes chooses an available PV in the system and allocates it to the Deployment or StatefulSets workload.

### <a id='static-pv-deployment'></a>Provision a Static PV for a Deployment Workload

To provision a static PV for a Deployment workload, the procedure is as follows:

1. Create VMDK files, replacing `DATASTORE` with your datastore directory name:

    ```
    [root@ESXi-1:~] cd /vmfs
    [root@ESXi-1:/vmfs] cd volumes/
    [root@ESXi-1:/vmfs/volumes] cd DATASTORE/
    [root@ESXi-1:/vmfs/volumes/7e6c0ca3-8c4873ed] cd kubevols/
    [root@ESXi-1:/vmfs/volumes/7e6c0ca3-8c4873ed/kubevols] vmkfstools -c 2G redis-master.vmdk
    ```

1. Define a PV using a YAML manifest file that contains a reference to the VMDK file. For example, create a file named `redis-master-pv.yaml` with the following contents:

    ```yaml
    apiVersion: v1
    kind: PersistentVolume
    metadata:
      name: redis-master-pv
    spec:
      capacity:
    	storage: 2Gi
      accessModes:
    	- ReadWriteOnce
      persistentVolumeReclaimPolicy: Retain
      vsphereVolume:
    	volumePath: "[NFS-LAB-DATASTORE] kubevols/redis-master"
    	fsType: ext4
    ```

1. Define a PVC using a YAML manifest file. For example, create a file named `redis-master-claim.yaml` with the following contents:

    ```yaml
    kind: PersistentVolumeClaim
    apiVersion: v1
    metadata:
      name: redis-master-claim
    spec:
      accessModes:
    	- ReadWriteOnce
      resources:
    	requests:
      	storage: 2Gi
    ```

1. Define a deployment using a YAML manifest file that references the PVC. For example, create a file named `redis-master.yaml` with the following contents:

    ```yaml
    apiVersion: extensions/v1beta1
    kind: Deployment
    metadata:
      name: redis-master
    …
    spec:
      template:
        spec:
          volumes:
      	  - name: redis-master-data
          persistentVolumeClaim:
            claimName: redis-master-claim
    ```

### <a id='static-pv-statefulsets'></a>Provision a Static PV for a StatefulSets Workload

To provision a static PV for a StatefulSets workload with three replicas, the procedure is as follows:

1. Create VMDK files, replacing `DATASTORE` with your datastore directory name:

    ```
    [root@ESXi-1:~] cd /vmfs
    [root@ESXi-1:/vmfs] cd volumes/
    [root@ESXi-1:/vmfs/volumes] cd DATASTORE/
    [root@ESXi-1:/vmfs/volumes/7e6c0ca3-8c4873ed] cd kubevols/
    [root@ESXi-1:/vmfs/volumes/7e6c0ca3-8c4873ed/kubevols] vmkfstools -c 10G mysql-pv-1.vmdk
    [root@ESXi-1:/vmfs/volumes/7e6c0ca3-8c4873ed/kubevols] vmkfstools -c 10G mysql-pv-2.vmdk
    [root@ESXi-1:/vmfs/volumes/7e6c0ca3-8c4873ed/kubevols] vmkfstools -c 10G mysql-pv-3.vmdk
    ```

1. Define a PV for the first replica using a YAML manifest file that contains a reference to the VMDK file. For example, create a file named `mysql-pv-1.yaml` with the following contents:

    ```yaml
    apiVersion: v1
    kind: PersistentVolume
    metadata:
      name: mysql-pv-1
    spec:
      capacity:
    	storage: 10Gi
      accessModes:
    	- ReadWriteOnce
      persistentVolumeReclaimPolicy: Retain
      vsphereVolume:
        volumePath: "[NFS-LAB-DATASTORE] kubevols/mysql-pv-1"
    	fsType: ext4
    ```

1. Define a PV for the second replica using a YAML manifest file that contains a reference to the VMDK file. For example, create a file named `mysql-pv-2.yaml` with the following contents:

    ```yaml
    apiVersion: v1
    kind: PersistentVolume
    metadata:
      name: mysql-pv-2
    spec:
      capacity:
    	storage: 10Gi
      accessModes:
    	- ReadWriteOnce
      persistentVolumeReclaimPolicy: Retain
      vsphereVolume:
        volumePath: "[NFS-LAB-DATASTORE] kubevols/mysql-pv-2"
    	fsType: ext4
    ```

1. Define a PV for the third replica using a YAML manifest file that contains a reference to the VMDK file. For example, create a file named `mysql-pv-3.yaml` with the following contents:

    ```yaml
    apiVersion: v1
    kind: PersistentVolume
    metadata:
      name: mysql-pv-3
    spec:
      capacity:
    	storage: 10Gi
      accessModes:
    	- ReadWriteOnce
      persistentVolumeReclaimPolicy: Retain
      vsphereVolume:
        volumePath: "[NFS-LAB-DATASTORE] kubevols/mysql-pv-3"
    	fsType: ext4
    ```

1. Define a StatefultSets object using a YAML manifest file. For example, create a file named `mysql-statefulsets.yaml` with the following contents:

    ```yaml
    piVersion: apps/v1
    kind: StatefulSet
    metadata:
      name: mysql
    spec:
      selector:
	    matchLabels:
          app: mysql
      serviceName: mysql
      replicas: 3
    ...
    volumeClaimTemplates:
      - metadata:
      	name: data
    	spec:
      	accessModes: ["ReadWriteOnce"]
      	resources:
        	requests:
          	storage: 10Gi
    ```
    <p class="note"><strong>Note</strong>: In previous steps you created a total of three PVs. The <code>spec.replicas: 3</code> field defines three replicas. Each replica is attached to one PV.</p>
    <p class="note"><strong>Note</strong>: In the volumeClaimTemplates section, you must specify the required storage size for each replica. Do not to refer to a StorageClass.</p>

## <a id='dynamic-pv'></a>Provision a Dynamic PV

For dynamic PV provisioning, the procedure is to define and create a PVC that automatically triggers the creation of the PV and its backend VMDK file. When the PV is created, Kubernetes knows which volume instance is available for use. When a PVC or volumeClaimTemplate is requested, Kubernetes chooses an available PV and allocates it to the Deployment or StatefulSets workload.

### <a id='dynamic-pv-deployment'></a>Provision a Dynamic PV for Deployment Workloads

For the Deployment workload with dynamic PV provisioning, the procedure is as follows:

1. Define a StorageClass using a YAML manifest file. For example, create a file named `redis-sc.yaml` with the following contents:

    ```yaml
    kind: StorageClass
    apiVersion: storage.k8s.io/v1
    metadata:
      name: thin-disk
    provisioner: kubernetes.io/vsphere-volume
    parameters:
    	datastore: Datastore-NFS-VM
    	diskformat: thin
    	fstype: ext3
    ```

1. Define a PVC using a YAML manifest file that references the StorageClass. For example, create a file named `redis-master-claim.yaml` with the following contents:

    ```yaml
    kind: PersistentVolumeClaim
    apiVersion: v1
    metadata:
      name: redis-master-claim
      annotations:
    	volume.beta.kubernetes.io/storage-class: thin-disk
    spec:
      accessModes:
    	- ReadWriteOnce
      resources:
    	requests:
      	storage: 2Gi
    ```
    <p class="note"><strong>Note</strong>: When you deploy the PVC, the vSphere Cloud Provider plugin automatically creates the PV and associated VMDK file.</p>

1. Define a Deployment using a YAML manifest file that references the PVC. For example, create a file named `redis-master.yaml` with the following contents:

    ```yaml
    apiVersion: extensions/v1beta1
    kind: Deployment
    metadata:
      name: redis-master
    …
    spec:
      template:
        spec:
          volumes:
      	  - name: redis-master-data
        	persistentVolumeClaim:
            claimName: redis-master-claim
    ```

### <a id='dynamic-pv-statefulsets'></a>Provision a Dynamic PV for StatefulSets Workloads

To provision a static PV for a StatefulSets workload with three replicas, the procedure is as follows:

1. Define a StorageClass using a YAML manifest file. For example, create a file named `mysql-sc.yaml` with the following contents:

    ```yaml
    kind: StorageClass
    apiVersion: storage.k8s.io/v1
    metadata:
      name: my-storage-class
    provisioner: kubernetes.io/vsphere-volume
    parameters:
    	datastore: Datastore-NFS-VM
    	diskformat: thin
    	fstype: ext3
    ```

1. Define a StatefultSets object using a YAML manifest file that references the StorageClass. For example, create a file named `mysql-statefulsets.yaml` with the following contents:

    ```yaml
    apiVersion: apps/v1
    kind: StatefulSet
    metadata:
      name: mysql
    spec:
    ...
    volumeClaimTemplates:
      - metadata:
      	name: data
    	spec:
      	accessModes: ["ReadWriteOnce"]
          storageClassName: "my-storage-class"
      	resources:
        	requests:
          	storage: 10Gi
    ```
    <p class="note"><strong>Note</strong>: In the volumeClaimTemplates, specify the required storage size for each replica. Unlike static provisioning, you must explicitly refer to the desired StorageClass when you use dynamic PV provisioning.</p>

### <a id='default-storage-class'></a>Specify a Default Storage Class

If you have or anticipate having more than one storage class for use with dynamic PVs for a Kubernetes cluster, you may want to designate a particular storage class as the default. This is useful to provide easy management of a storage volume without having to set up or communicate specialized StorageClasses across the cluster. If necessary a developer can change the default storage class in the PVC definition. See the [Kubernetes documentation](https://kubernetes.io/docs/tasks/administer-cluster/change-default-storage-class/) for more information.

To specify a storage class as the default for a Kubernetes cluster, use the annotation `storageclass.kubernetes.io/is-default-class: "true"`, for example:

    ```yaml
    kind: StorageClass
    apiVersion: storage.k8s.io/v1
    metadata:
      name: thin-disk
      annotations:
  		storageclass.kubernetes.io/is-default-class: "true"
    provisioner: kubernetes.io/vsphere-volume
    parameters:
    	datastore: Datastore-NFS-VM
    	diskformat: thin
    	fstype: ext3
    ```

### <a id='dynamic-pv-statefulsets'></a>Provision Dynamic PVs for Use with PKS

Dynamic PersistentVolume (PV) provisioning gives developers the freedom to provision storage when they need it without manual intervention from a Kubernetes cluster administrator. To enable dynamic PV provisioning, the Kubernetes cluster administrator defines one or more storage classes.  

To order the storage, the developer creates a PersistentVolumeClaim (PVC). The PVC determines the specification for the storage to be provisioned. After the PVC is created, the storage device and the PV are automatically created. All the developer has to do is mount the volume in the pod deployment spec. 

PKS supports dynamic PV provisioning by providing storage classes for all supported cloud providers, as well as an example PVC.

Perform the steps in this section to register one or more storage classes and define a PVC that can be applied to newly-created pods.

1. Download the StorageClass spec for your cloud provider.

  * **AWS**: <pre class="terminal">$ wget https&#58;//raw.githubusercontent.com/cloudfoundry-incubator/kubo-ci/master/specs/storage-class-aws.yml</pre>

  * **Azure**: <pre class="terminal">$ wget https&#58;//raw.githubusercontent.com/cloudfoundry-incubator/kubo-ci/master/specs/storage-class-azure.yml</pre>

  * **GCP**: <pre class="terminal">$ wget https&#58;//raw.githubusercontent.com/cloudfoundry-incubator/kubo-ci/master/specs/storage-class-gcp.yml</pre>

  * **vSphere**: <pre class="terminal">$ wget https&#58;//raw.githubusercontent.com/cloudfoundry-incubator/kubo-ci/master/specs/storage-class-vsphere.yml</pre>

  After downloading the vSphere StorageClass spec, replace the contents of the file with the following YAML to create the correct StorageClass for vSphere:

          ```yaml
          kind: StorageClass
          apiVersion: storage.k8s.io/v1
          metadata:
            name: thin
            annotations:
              storageclass.kubernetes.io/is-default-class: "true"
          provisioner: kubernetes.io/vsphere-volume
          parameters:
              diskformat: thin
          ```

1. Apply the spec by running `kubectl create -f STORAGE-CLASS-SPEC.yml`.
Replace `STORAGE-CLASS-SPEC` with the name of the file you downloaded in the previous step.

For example:
<pre class="terminal">$ kubectl create -f storage-class-gcp.yml</pre>

1. Run the following command to download the example PVC:
<pre class="terminal">$ wget https&#58;//raw.githubusercontent.com/cloudfoundry-incubator/kubo-ci/master/specs/persistent-volume-claim.yml
</pre>

1. Run the following command to apply the PVC:
<pre class="terminal">
$ kubectl create -f persistent-volume-claim.yml
</pre>
  * To confirm you applied the PVC, run the following command:
  <pre class="terminal">
  $ kubectl get pvc -o wide
  </pre>

1. To use the dynamic PV, create a pod that uses the PVC.
See the [pv-guestbook.yml configuration file](https://github.com/cloudfoundry-incubator/kubo-ci/blob/master/specs/pv-guestbook.yml) as an example.